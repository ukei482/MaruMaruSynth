# JUCE + Rust : 3次元ウェーブテーブル・シンセ — プロジェクト設計

> 概要：ユーザーが任意のオーディオファイルをプラグイン内で解析して周期ごとに切り出し正規化したデータを保持、3次元ウェーブテーブル（周期×サンプル位置×電子波形モード）を構築して MIDI 再生するシンセ。

---

## 目次
1. アーキテクチャ概観
2. モジュール構成（Rust / JUCE）
3. データ構造と保存フォーマット
4. FFI（Rust ↔ C++/JUCE）API設計（関数一覧・引数）
5. Rust 内部 API（関数シグネチャ／責務）
6. JUCE 側インターフェース（C++ラッパー）
7. 再生アルゴリズム（補間・ピッチ追従・ボイス設計）
8. 同期・スレッド安全性の方針
9. ファイル I/O / プリセット管理
10. テスト / デバッグ / ビルド手順
11. 優先度付き TODO

---

## 1. アーキテクチャ概観

- **フェーズ分離**
  - 解析フェーズ（非リアルタイム、GUI からトリガー）: ファイルを Rust 側で解析し `WaveTable` を生成 → キャッシュ（メモリ／ディスク）
  - 再生フェーズ（リアルタイム）: JUCE の audio thread から Rust の軽量処理を呼び出し波形を生成
- **責務**
  - JUCE (C++): GUI, ファイル選択, パラメータ管理 (AudioProcessorValueTreeState), audio callback で Rust を呼ぶ
  - Rust: 解析（ピッチ推定・周期抽出・正規化）、WaveTable 管理、voice 管理、リアルタイム処理（低レイテンシ）
- **データ永続化**: 解析結果はプリセットとして保存可能（JSON+バイナリ or HDF5 推奨）

---

## 2. モジュール構成

### Rust 側
- `analyzer` : ファイル読み込み、ピッチ推定、周期切り出し、正規化
- `wavetable` : 2D/3D テーブル構築、補間ロジック
- `synth` : voice 管理、エンベロープ、フィルタ
- `io` : プリセット保存/読み込み、バイナリフォーマット
- `ffi` : 外部公開関数、Context 管理

### JUCE (C++) 側
- `PluginProcessor` : AudioProcessor の実装（prepareToPlay, processBlock）
- `PluginEditor` : GUI（ロード、進捗表示、パラメータ）
- `RustBridge` : Rust の DLL をロードして呼ぶ薄いラッパー

---

## 3. データ構造と保存フォーマット

### in-memory (Rust)
```rust
pub struct WaveTable {
    sample_rate: f32,
    cycles: Vec<Vec<f32>>,     // [cycle_index][n_samples_per_cycle] (normalized -1.0..1.0)
    freq_track: Vec<f32>,      // 周波数の推移（Hz）
    synth_modes: Vec<Vec<f32>>, // z軸用波形群（同じサンプル長で揃える）
}
```

- `cycles` の各周期は **同じ長さにリサンプル**して保存（例: N = 256 / 512 / 1024）するのが扱いやすい
- `freq_track` は解析時に得た F0 の時間走査配列（フレーム単位）

### 保存フォーマット候補
1. **ZIP アーカイブ (metadata.json + cycles.bin + freq.bin + synth_modes.bin)**
   - 長所: シンプル、移植性高い
   - 短所: 自前実装が必要
2. **HDF5**
   - 長所: 階層的、圧縮、ランダムアクセスに強い
   - 短所: 重量級、クレートが大きくなる
3. **JSON (+ bincode binary blobs)**
   - 長所: メタは可読、配列は効率的にバイナリ化
   - 短所: 実装の一貫性注意

推奨：まずは ZIP (metadata.json + 3つのバイナリ) を実装し、要望が出れば HDF5 に移行。

---

## 4. FFI（Rust ↔ C++/JUCE）API設計

> 方針: audio thread 側はブロッキングしない。解析は GUI スレッド or 背景スレッドで呼ぶ。Rust 側の Context (opaque pointer) を使い、所有権は Rust にする。

### 共通型
- `typedef void* MMHandle;` // C 側では不透明ポインタ
- `typedef void (*MMProgressCb)(float progress, void* user_data);` // 0.0..1.0, allow null

### 基本ライフサイクル
```c
// create/destroy
MMHandle mm_create_context(float sample_rate);
void mm_destroy_context(MMHandle ctx);

// analysis
int mm_analyze_file(MMHandle ctx, const char* path, MMProgressCb progress_cb, void* user_data);
// returns 0 on success, non-zero on error

// preset save/load
int mm_save_preset(MMHandle ctx, const char* path);
int mm_load_preset(MMHandle ctx, const char* path);

// query wavetable metadata
int mm_get_wavetable_dims(MMHandle ctx, uint32_t* out_cycles, uint32_t* out_samples_per_cycle, uint32_t* out_synth_modes);

// realtime control
void mm_note_on(MMHandle ctx, uint8_t note, uint8_t velocity);
void mm_note_off(MMHandle ctx, uint8_t note);

// set/get parameters (generic)
void mm_set_param_f32(MMHandle ctx, int32_t param_id, float value);
float mm_get_param_f32(MMHandle ctx, int32_t param_id);

// audio processing: outputs is pointer to array of float* (channels)
void mm_process(MMHandle ctx, float** outputs, uint32_t num_channels, uint32_t num_samples);

// optional: request preview waveform for GUI (copy into caller buffer)
int mm_fill_cycle_preview(MMHandle ctx, uint32_t cycle_index, float* out_buffer, uint32_t out_len);
```

**注意点**
- `mm_process` は audio thread から呼ぶ。内部でメモリ確保やロックでブロッキングしないこと。
- `mm_analyze_file` はブロッキング関数。UI からはバックグラウンドスレッドで呼ぶか、progress_cb を渡して進捗を受け取る。
- `mm_get_wavetable_dims` は軽量で即時に呼べる。

---

## 5. Rust 内部 API（関数シグネチャ例）

### analyzer モジュール
```rust
pub struct AnalyzeConfig {
    pub target_cycle_len: usize, // samples per cycle after resample (e.g. 512)
    pub min_f0: f32,
    pub max_f0: f32,
    pub pitch_algo: PitchAlgo, // enum
}

// high-level
pub fn analyze_file<P: AsRef<Path>>(path: P, cfg: &AnalyzeConfig) -> Result<WaveTable, AnalyzeError>;

// lower-level
pub fn estimate_f0(signal: &[f32], sr: f32, cfg: &EstimateF0Config) -> Vec<f32>;
pub fn extract_cycles(signal: &[f32], f0: &[f32], sr: f32, target_len: usize) -> Vec<Vec<f32>>;
```

### wavetable モジュール
```rust
impl WaveTable {
    pub fn from_cycles(cycles: Vec<Vec<f32>>, freq_track: Vec<f32>, synth_modes: Vec<Vec<f32>>, sr: f32) -> Self;
    // 三次元的サンプル取得（補間つき）
    pub fn sample_trilinear(&self, cycle_idx: f32, sample_pos: f32, synth_mode_idx: f32) -> f32;
}
```

### synth モジュール
```rust
pub struct Voice {
    pub note: u8,
    pub velocity: u8,
    pub phase: f32,
    pub phase_inc: f32,
    pub active: bool,
    // envelope state etc.
}

impl Voice {
    pub fn new(note:u8, vel:u8, sr:f32) -> Self;
    pub fn process(&mut self, wavetable: &WaveTable, out: &mut [f32], num_samples: usize, sample_rate: f32);
}

pub struct VoiceManager {
    voices: Vec<Voice>,
    max_voices: usize,
}
impl VoiceManager {
    pub fn note_on(&mut self, note:u8, vel:u8);
    pub fn note_off(&mut self, note:u8);
    pub fn process(&mut self, wavetable: &WaveTable, outputs: &mut [&mut [f32]], num_samples: usize, sr:f32);
}
```

---

## 6. JUCE 側インターフェース（C++ラッパー）

### 使用イメージ（C++）
```cpp
class RustBridge {
public:
    RustBridge();
    ~RustBridge();
    bool create(float sampleRate);
    void destroy();

    // analysis (call from background thread)
    int analyzeFile(const juce::String& path, std::function<void(float)> progressCb);

    // realtime
    void noteOn(uint8_t note, uint8_t vel);
    void noteOff(uint8_t note);
    void process(juce::AudioBuffer<float>& buffer);

    // params
    void setParam(int id, float v);
};
```

- `analyzeFile` は JUCE の `ThreadPoolJob` などで呼び、UI には `progressCb` を通して進捗を渡す。

---

## 7. 再生アルゴリズム（詳細）

### 周期→周波数マッピング
- 各周期は元の解析時点のピッチを持つ（`freq_track`）。再生時に MIDI ノートの周波数に合わせて **cycle_index を補間**して選択する。
- 例: base cycle 0..N-1 にはそれぞれ f0_mean がある → 今回の再生周波数 f_target に対して cycle_idx = map_f_to_index(f_target)

### サンプル位置・位相管理
- 各 voice は位相加算器（phase += phase_inc）で sample_pos を読み出す。
- `phase_inc = f_target * cycle_len / sample_rate` （cycle_len は wavetable のサンプル数）

### 補間
- cycle方向（x軸）: linear or cubic interpolation across neighboring cycles
- sample位置（y軸）: linear/cubic on waveform samples
- z軸（synth modes）: either additive blend between stored synth waveforms or include synth as separate signal and mix

提案: 最初は **線型補間 (bilinear)** を実装し、動作確認後に高品位補間へ移行。

### アンチエイリアス
- ウェーブテーブルをピッチシフトする際は高周波が問題になる。対策:
  - 上位オクターブでの再生を制限
  - 必要に応じて再生時に単純なローパスフィルタを設ける
  - もしくは wavetable に複数の帯域バージョンを準備（multiband wavetables）

---

## 8. 同期・スレッド安全性の方針

- **解析は background thread** で実行。解析が完了したら新しい `WaveTable` を生成して `Arc` で保持し、atomic pointer swap (Rust: `Arc<WaveTable>` + `std::sync::atomic::AtomicPtr`) で audio thread へ切り替える。
- audio thread 内の `mm_process` は **ロック不可**。常に現在の `Arc` をクローンして参照する（`Arc::clone` は cheap）。
- GUI スレッドが `mm_save_preset` を呼ぶ際は I/O を行うため、UI をブロックしない。

---

## 9. ファイル I/O / プリセット管理

- **プリセット保存 API** は `mm_save_preset(ctx, path)` を提供。
- 推奨フォーマット：ZIP で `metadata.json` + 3 バイナリ (`cycles.bin` `freq.bin` `synth_modes.bin`) を格納。
- `metadata.json` には: sample_rate, cycles_count, samples_per_cycle, synth_modes_count, timestamps, original_file_name など。

---

## 10. テスト / デバッグ / ビルド手順

- **ユニットテスト**: pitch estimation, extract_cycles, interpolation
- **Integration test**: small WAV を解析して得られた WaveTable を再生して波形をファイル出力（headless）で比較
- **手順（開発時）**:
  1. Rust cdylib をビルド (`cargo build --release --target ...`) producing `libmm.*`
  2. JUCE CMake プロジェクトで DLL をリンク/LoadLibrary
  3. Standalone で確認 → DAW で VST3 をテスト

---

## 11. 優先度付き TODO

1. 最小実装（MVP）
   - Rust: analyze_file (WAV)、WaveTable in-memory、note_on/off、process
   - JUCE: GUI (ファイルロード), background analysis job, audio routing
2. プリセット保存/読み込み
3. GUI: 波形/周波数トラックの表示
4. 高品質補間、アンチエイリアス
5. パラメータ自動化と DAW プリセット統合

---

## 付録: 例 — Rust FFI のヘッダ（Cスタイル）
```c
#ifndef MARU_MARU_BRIDGE_H
#define MARU_MARU_BRIDGE_H
#include <stdint.h>
#ifdef __cplusplus
extern "C" {
#endif

typedef void* MMHandle;
typedef void (*MMProgressCb)(float progress, void* user_data);

MMHandle mm_create_context(float sample_rate);
void mm_destroy_context(MMHandle ctx);

int mm_analyze_file(MMHandle ctx, const char* path, MMProgressCb progress_cb, void* user_data);
int mm_save_preset(MMHandle ctx, const char* path);
int mm_load_preset(MMHandle ctx, const char* path);

int mm_get_wavetable_dims(MMHandle ctx, uint32_t* out_cycles, uint32_t* out_samples_per_cycle, uint32_t* out_synth_modes);

void mm_note_on(MMHandle ctx, uint8_t note, uint8_t velocity);
void mm_note_off(MMHandle ctx, uint8_t note);

void mm_set_param_f32(MMHandle ctx, int32_t param_id, float value);
float mm_get_param_f32(MMHandle ctx, int32_t param_id);

void mm_process(MMHandle ctx, float** outputs, uint32_t num_channels, uint32_t num_samples);

int mm_fill_cycle_preview(MMHandle ctx, uint32_t cycle_index, float* out_buffer, uint32_t out_len);

#ifdef __cplusplus
}
#endif
#endif
```

---

### 最後に
このドキュメントは「第一案」です。次は **どのレイヤー** を詳細化しますか？
- `FFI API` の細かい型とエラーコード設計（推奨: まずここ）
- `Rust analyzer` の関数シグネチャとアルゴリズム（YIN 等）
- `Voice`/`synth` の処理詳細（補間式・エンベロープ）
- `保存フォーマット` のバイナリ仕様（ヘッダ定義）

希望の着手箇所を教えてください。

(注) このドキュメントは編集・追記可能です。続けて関数設計を詰めていきましょう。

